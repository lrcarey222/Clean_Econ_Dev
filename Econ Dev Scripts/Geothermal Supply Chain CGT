# ==============================================================================
# Geothermal-Adjacent Supply-Chain Analysis - Optimized for File Size (<2MB)
# Updated to include the full set of six-digit NAICS codes requested
# Industry titles are always taken from the `industry_desc` field in the CGT
# dataset, so no hard-coded names appear in this script.
# ==============================================================================

# ------------------------------------------------------------------------------
# 1) Load libraries
# ------------------------------------------------------------------------------
library(readr)
library(dplyr)
library(tidyr)
library(stringr)

# ------------------------------------------------------------------------------
# 2) Read in the data (specify the correct encoding if UTF-8 is wrong for you)
# ------------------------------------------------------------------------------
cgt_county_data <- read_csv(
  "~/Library/CloudStorage/OneDrive-RMI/US Program - Documents/6_Projects/Clean Regional Economic Development/ACRE/Data/CGT_county_data/modified_CGT_files/cgt_county_data_with_CD_and_EC_20250213_130456.csv",
  locale = locale(encoding = "UTF-8")   # change to "Latin1" or "windows-1252" if needed
)

# ------------------------------------------------------------------------------
# 3) Define the complete NAICS code set and check that all codes exist
# ------------------------------------------------------------------------------

# --- Original six codes --------------------------------------
original_codes <- c(
  333132, # Oil & Gas Field Machinery mfg
  331210, # Iron & Steel Pipe & Tube mfg
  334513, # Instruments & Related Products mfg
  333611, # Turbines & Generator Sets mfg
  332410, # Power Boiler & Heat Exchanger mfg
  333914  # Measuring, Dispensing & Other Pumping Equip. mfg
)

# --- Newly added geothermal-specific manufacturing codes (via CATF)----------------------
catf_suggested_additions <- c(
  334519, # Geophysical Instruments mfg
  333998, # Steam Separating Machinery mfg
  327310, # Cement mfg
  332911, # Industrial Valve mfg
  333415, # A/C, Warm-Air, & Commercial Refrigeration Equip. mfg
  334511, # Search, Detection, Navigation & Nautical Sys./Instr. mfg
  335311, # Power, Distribution & Specialty Transformer mfg
  335312, # Motor & Generator mfg
  335313, # Switchgear & Switchboard Apparatus mfg
  335314  # Relay & Industrial Control mfg
)

# --- Broader "stretch" supply-chain codes (via CATF) -------------------------------------
support_codes <- c(
  325180, 325199,                     # Inorganic & Organic Basic Chemicals mfg
  326220, 326291,                     # Rubber & Plastic Hoses/Belting; Rubber Prod. for Mech. Use
  332111, 332312, 332420, 332710,     # Forging; Structural Metal; Heavy-Gauge Tanks; Machine Shops
  332811, 332912, 332996,             # Metal Heat Treating; Fluid Power Valves; Fabricated Pipe
  333120,                             # Construction Machinery mfg
  334416, 334516,                     # Capacitors/Resistors/Coils; Analytical Instruments mfg
  335931                              # Current-Carrying Wiring Devices mfg
)

# --- Combine, deduplicate, and sort (exclude "stretch" codes for now) ------------------------------------------
relevant_codes <- sort(unique(c(original_codes, catf_suggested_additions)))

# --- Debug: confirm presence in the source data ------------------------------
missing_in_source <- setdiff(relevant_codes, unique(cgt_county_data$industry_code))
if (length(missing_in_source) == 0) {
  cat("All specified NAICS codes are present in the source data.\n")
} else {
  warning(
    "The following NAICS codes are missing from the source data: ",
    paste(missing_in_source, collapse = ", "), "\n"
  )
}

# ------------------------------------------------------------------------------
# 4) Calculate normalized PCI scores for complexity weighting
# ------------------------------------------------------------------------------
# Get unique industry PCI scores where aggregation_level is 4
industry_pci <- cgt_county_data %>%
  filter(aggregation_level == 4) %>%
  select(industry_code, industry_desc, pci) %>%
  distinct() %>%
  group_by(industry_code, industry_desc) %>%
  summarise(pci = mean(pci, na.rm = TRUE), .groups = "drop")

# Normalize PCI scores to 0-100 scale
min_pci <- min(industry_pci$pci, na.rm = TRUE)
max_pci <- max(industry_pci$pci, na.rm = TRUE)
industry_pci <- industry_pci %>%
  mutate(
    industry_complexity_normalized = (pci - min_pci) / (max_pci - min_pci) * 100
  )

# ------------------------------------------------------------------------------
# 5) Filter CGT data for these NAICS codes
# ------------------------------------------------------------------------------
cgt_filtered_geothermal <- cgt_county_data %>%
  filter(industry_code %in% relevant_codes)

# Optional debug: make sure filtering worked
missing_after_filter <- setdiff(relevant_codes, unique(cgt_filtered_geothermal$industry_code))
if (length(missing_after_filter) > 0) {
  warning(
    "After filtering, these NAICS codes are still missing: ",
    paste(missing_after_filter, collapse = ", "), "\n"
  )
}

# ------------------------------------------------------------------------------
# 6) Add presence/advantage flags and round density percentile
# ------------------------------------------------------------------------------
cgt_filtered_geothermal <- cgt_filtered_geothermal %>%
  mutate(
    density_county_percentile_from_rank = round(density_county_percentile_from_rank, 2),
    presence  = rca != 0,
    advantage = rca >= 1
  )

# ------------------------------------------------------------------------------
# 6a) Normalize density scores (per industry_code)
# ------------------------------------------------------------------------------
cgt_filtered_geothermal <- cgt_filtered_geothermal %>%
  mutate(
    density_score_normalized_0_100 = NA_real_
  )

for (code in relevant_codes) {
  # Normalize density scores to 0-100 ------------------------------------------
  idx_density <- cgt_filtered_geothermal$industry_code == code & !is.na(cgt_filtered_geothermal$density)
  if (sum(idx_density) > 0) {
    density_values <- cgt_filtered_geothermal$density[idx_density]
    min_density <- min(density_values, na.rm = TRUE)
    max_density <- max(density_values, na.rm = TRUE)
    
    if (max_density > min_density) {
      cgt_filtered_geothermal$density_score_normalized_0_100[idx_density] <- 
        round(((density_values - min_density) / (max_density - min_density)) * 100, 2)
    } else {
      # If all values are the same, set to 50
      cgt_filtered_geothermal$density_score_normalized_0_100[idx_density] <- 50
    }
  }
}

# ------------------------------------------------------------------------------
# 7) Add complexity scores to filtered data
# ------------------------------------------------------------------------------
cgt_filtered_geothermal <- cgt_filtered_geothermal %>%
  left_join(
    industry_pci %>% select(industry_code, industry_complexity_normalized),
    by = "industry_code"
  )

# ------------------------------------------------------------------------------
# 8) County-level summary with requested metrics
# ------------------------------------------------------------------------------
cgt_county_summary <- cgt_filtered_geothermal %>%
  group_by(
    State_Name, County_Name, county_geoid,
    `119th Congressional District(s)`
  ) %>%
  summarise(
    `Industries Present` = {
      out <- str_c(
        unique(str_c(industry_desc[presence], " (NAICS ", industry_code[presence], ")")),
        collapse = "; "
      ); ifelse(out == "", NA_character_, out)
    },
    
    `Comparative-Advantage Industries` = {
      out <- str_c(
        unique(str_c(industry_desc[advantage], " (NAICS ", industry_code[advantage], ")")),
        collapse = "; "
      ); ifelse(out == "", NA_character_, out)
    },
    
    `Highest Density Score`          = max(density, na.rm = TRUE),
    `Highest-Density Industry`       = {
      i <- which.max(density)
      if (length(i) && !all(is.na(density))) {
        str_c(industry_desc[i], " (NAICS ", industry_code[i], ")")
      } else NA_character_
    },
    
    `Highest Density Percentile Score` = max(density_county_percentile_from_rank, na.rm = TRUE),
    `Highest-Percentile Industry`      = {
      i <- which.max(density_county_percentile_from_rank)
      if (length(i) && !all(is.na(density_county_percentile_from_rank))) {
        str_c(industry_desc[i], " (NAICS ", industry_code[i], ")")
      } else NA_character_
    },
    
    `Industry Presence Count`           = sum(presence,   na.rm = TRUE),
    `Industry Comparative Advantage Count` = sum(advantage, na.rm = TRUE),
    
    # Calculate complexity-weighted metrics
    `Complexity-Weighted Feasibility` = {
      # Weighted average of density using normalized complexity scores
      weights <- industry_complexity_normalized[!is.na(density) & !is.na(industry_complexity_normalized)]
      values <- density[!is.na(density) & !is.na(industry_complexity_normalized)]
      if (length(weights) > 0 && sum(weights) > 0) {
        sum(values * weights) / sum(weights)
      } else {
        NA_real_
      }
    },
    
    `Complexity-Weighted Comparative Advantage` = {
      # Weighted average of M (employment/count) using normalized complexity scores
      weights <- industry_complexity_normalized[!is.na(M) & !is.na(industry_complexity_normalized)]
      values <- M[!is.na(M) & !is.na(industry_complexity_normalized)]
      if (length(weights) > 0 && sum(weights) > 0) {
        sum(values * weights) / sum(weights)
      } else {
        NA_real_
      }
    },
    
    .groups = "drop"
  )

# ------------------------------------------------------------------------------
# 9) Pivot the detailed industry metrics wide
# ------------------------------------------------------------------------------
cgt_geothermal_wide <- cgt_filtered_geothermal %>%
  select(
    State_Name, County_Name, county_geoid,
    `119th Congressional District(s)`,
    industry_desc, industry_code,
    rca, density_score_normalized_0_100, density_county_percentile_from_rank,
    presence, advantage
  ) %>%
  distinct() %>%
  pivot_wider(
    id_cols = c(
      State_Name, County_Name, county_geoid,
      `119th Congressional District(s)`
    ),
    names_from  = c(industry_desc, industry_code),
    names_glue  = "{industry_desc} (NAICS {industry_code}): {.value}",
    values_from = c(
      rca, density_score_normalized_0_100, density_county_percentile_from_rank,
      presence, advantage
    )
  ) %>%
  {  # rename presence/advantage columns for readability ------------------------
    colnames(.) <- sub(": presence$",  ": Industry Presence in County",             colnames(.))
    colnames(.) <- sub(": advantage$", ": Existing Comparative Advantage for County", colnames(.))
    .
  }

# ------------------------------------------------------------------------------
# 10) Combine the summary and wide datasets
# ------------------------------------------------------------------------------
final_cgt_geothermal <- cgt_county_summary %>%
  left_join(
    cgt_geothermal_wide,
    by = c(
      "State_Name", "County_Name", "county_geoid",
      "119th Congressional District(s)"
    )
  )

# ------------------------------------------------------------------------------
# 11) Inspect the final dataset (optional)
# ------------------------------------------------------------------------------
glimpse(final_cgt_geothermal)

# ------------------------------------------------------------------------------
# 12) Write the final dataset to disk
# ------------------------------------------------------------------------------
write_csv(final_cgt_geothermal, "cgt_geothermal_wide_plus_summary_optimized.csv")

# ------------------------------------------------------------------------------
# End of Script
# ------------------------------------------------------------------------------
